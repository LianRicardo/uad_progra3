#pragma once

#ifdef OBJLoaderDLL_Exports
#else
#define OBJLoaderDLL_Exports __declspec(dllimport)
#endif //OBJLoaderDLL_Exports
#include <string>
using namespace std;

class C3DModel
{


protected:
	unsigned int m_shaderProgramId;                                   // Shader program identifier generated by OpenGL
	unsigned int m_graphicsMemoryObjectId;                            // Vertex Array Object identifier generated by OpenGL

	unsigned short *m_vertexIndices;                                  // Dynamically-allocated array of vertex indices for this model
	unsigned short *m_normalIndices;                                  // Dynamically-allocated array of normal indices for this model
	unsigned short *m_UVindices;                                      // Dynamically-allocated array of UV coord indices for this model


	float *m_verticesRaw;                                             // Dynamically-allocated array of vertices (raw float values)
	float *m_normalsRaw;                                              // Dynamically-allocated array of normals (raw float values)
	float *m_uvCoordsRaw;                                             // Dynamically-allocated array of UV coords (raw float values)

	int m_numVertices, m_numNormals, m_numUVCoords, m_numFaces;       // Total number of vertices, normals, UV coords, and faces in this model
	int m_currentVertex, m_currentNormal, m_currentUV, m_currentFace; // Aux counters used when loading an object from file
	bool m_Initialized;                                               // Does this C3DModel object contain valid data? (loaded from file)

private:
	virtual void reset() = 0;                                                     // Cleanup any allocated memory

protected:
	virtual bool loadFromFile(const char * const filename) = 0;

public:
	C3DModel()
		: m_vertexIndices(NULL),
		m_normalIndices(NULL),
		m_UVindices(NULL),
		m_verticesRaw(NULL),
		m_normalsRaw(NULL),
		m_uvCoordsRaw(NULL),
		m_Initialized(false),
		m_numVertices(0),
		m_numNormals(0),
		m_numUVCoords(0),
		m_numFaces(0),
		m_currentVertex(0),
		m_currentNormal(0),
		m_currentUV(0),
		m_currentFace(0),
		m_graphicsMemoryObjectId(0),
		m_shaderProgramId(0)
	{

	}
	virtual ~C3DModel()
	{
		//reset();
	}

	bool isInitialized() const { return m_Initialized; }
	static C3DModel* Load(wchar_t * filename);

	unsigned int *getGraphicsMemoryObjectId() { return &m_graphicsMemoryObjectId; }
	void setGraphicsMemoryObjectId(unsigned int id) { m_graphicsMemoryObjectId = id; }

	unsigned int *getShaderProgramId() { return &m_shaderProgramId; }
	void setShaderProgramId(unsigned int id) { m_shaderProgramId = id; }

	int getNumVertices() const { return m_numVertices; }
	int getNumNormals() const { return m_numNormals; }
	int getNumUVCoords() const { return m_numUVCoords; }
	int getNumFaces() const { return m_numFaces; }
	float * const getModelVertices() { return m_verticesRaw; }
	float * const getModelNormals() { return m_normalsRaw; }
	float * const getModelUVCoords() { return m_uvCoordsRaw; }
	unsigned short * const getModelVertexIndices() { return m_vertexIndices; }
	unsigned short * const getModelNormalIndices() { return m_normalIndices; }
	unsigned short * const getModelUVCoordIndices() { return m_UVindices; }

	// Overloaded < operator. This is specifically used in the final exam to allow two 3D objects to be compared and decide on which side of the
	// binary tree it needs to be inserted.
	bool operator<(const C3DModel &other)
	{
		return (m_numFaces < other.m_numFaces);
	}
	// Overloaded > operator. This is specifically used in the final exam to allow two 3D objects to be compared and decide on which side of the
	// binary tree it needs to be inserted.
	bool operator>(const C3DModel &other)
	{
		return (m_numFaces > other.m_numFaces);
	}
	// Overloaded << operator. This is used in the final exam.
	friend ostream &operator<<(ostream &out, const C3DModel &model) {
		// Commented-out, this is rendered every frame...
		// out << "Num faces: " << model.getNumFaces() << endl;
		return out;
	}
};


class CVector3
{
private:
	float m_X, m_Y, m_Z;

public:
	CVector3()
	: m_X(0.0f),
		m_Y(0.0f),
		m_Z(0.0f)
	{
	}
	CVector3(float _x, float _y, float _z);
	CVector3(const CVector3 &other);
	~CVector3()
	{

	}

	CVector3& operator=(const CVector3 &other);
	CVector3& operator+=(const CVector3 &other);
	CVector3 CVector3::cross(const CVector3 & other);
	CVector3 CVector3::operator-(const CVector3 & other);

	void setValues(float _x, float _y, float _z);
	void setValues(float *values)
	{
		m_X = *(values + 0);
		m_Y = *(values + 1);
		m_Z = *(values + 2);
	}
	float getX() const { return m_X; }
	float getY() const { return m_Y; }
	float getZ() const { return m_Z; }
	void getValues(float *values) const { values[0] = m_X; values[1] = m_Y; values[2] = m_Z; }

	inline static CVector3 ZeroVector()
	{
		return CVector3(0.0f, 0.0f, 0.0f);
	}
};


class OBJLoaderDLL_Exports C3DModel_obj : public C3DModel
{
	public:
		~C3DModel_obj();
		C3DModel_obj();

	private:
		CVector3 *m_vertices;          // Dynamically-allocated array of vertices
		CVector3 *m_normals;           // Dynamically-allocated array of normals
		CVector3 *m_UVCoords;          // Dynamically-allocated array of UV coords
	public:
		void reset();
		// Methods to read a model in the .obj file format
		bool readFile(const char * const filename, bool countOnly);       // Read object from file 
		bool parseLine(std::string line, bool countOnly, int lineNumber); // Parse line
	protected:
		bool loadFromFile(const char * const filename);
};

